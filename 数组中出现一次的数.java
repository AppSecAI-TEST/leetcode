一。数组A中，除了某一个数字x之外，其他数字都出现了三次，而x出现了一次。
每一位上的统计结果都可以被3整除。而再对该数组添加任何一个数，
如果这个数在二进制的某位上为1都将导致该位上1的个数不能被3整除。
因此通过统计二进制上每位1的个数就可以推断出x在该位置上是0还是1了，这样就能计算出x了。
 for (i = 0; i < n; i++)  
    for (j = 0; j < 32; j++)  
      bits[j] += ((a[i] >> j) & 1);  
  // 如果某位上的结果不能被整除，则肯定目标数字在这一位上为  
  int result = 0;  
  for (j = 0; j < 32; j++)  
    if (bits[j] % 3 != 0)  
      result += (1 << j);  
  return result;  
} 
二。在一个数组中除两个数字只出现1次外，其它数字都出现了2次， 要求尽快找出这两个数字。
分析：所有数做异或，则出现两个次的数相抵消，那么最终的结果就是那两个出现一次的数x和y的异或结果，即x xor y ，且这个值非0
既然x xor y非0，我们可以找到二进制表示中某一个为1的位（bit）（例如最低位），把所有的数按这位为1和为0分开。
在该位为0和为1的数中，各有一个数只出现一次。 （一个是x，另一个是y)
int xXory = 0;
for (int i = 0; i < n; ++i) xXory ^= a[i];
int mask = 1;
for (; (xXory & mask) == 0; mask <<= 1);
int x = 0, y = 0;
for (int i = 0; i < n; ++i) 
		if (a[i] & mask) x ^= a[i];
		else y ^= a[i];
三。第一个缺失的正整数
例如[3,4,-1,1] 返回值为2
假设[0,i) 对应的数为[1，i+1）,第i个位置上，数值为i+1
for(int i=0;i<n;i++){

  if(A[i]==i+1){
    i++;
  }
  else if(A[i]<i+1||A[i]>n||A[A[i]-1]==A[i]){  //A[A[i]-1]==A[i] 情况为(1,2,3,2) 即A[3]的位置已经在A[A[3](2)-1] A[1]的位置出现
    A[i]=A[--n] //快速删除数
  }

  else{
    swap(A[A[i]-1],A[i]) //将i放在i-1位置上
  }

 return n+1;

}
